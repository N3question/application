first_appでは、

1.Homesコントローラを作成する
2.コントローラ内にtopアクションを作成する
3.app/views/homes/top.html.erbを作成する
4.config/routes.rbにhomes#topに対応するRoutingを作成する
といった手順で実装

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Railsはコントローラ作成と同時に、
必要なviewファイルの作成や記述の追加を、
簡単に実現できる
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

▼　その方法
ーーーーーーーーーーーーーーー
$ rails g controller homes top
ーーーーーーーーーーーーーーー


＜Listsコントローラ＞
listsコントローラというコントローラを新しく作っていきます。 
listsコントローラはhomesコントローラと違い、
その名の通りListモデルを扱うコントローラです。



＜Listsコントローラに定義するアクション＞
# モデルを扱うコントローラでは、データを操作するための
# 7つのアクションを以下の名前で定義するのが一般的

new      ...データの新規作成フォームを表示する
create   ...データを追加（保存）する
index    ...データの一覧を表示する
show     ...データの内容（詳細）を表示する
edit     ...データを更新するためのフォームを表示する
update   ...データを更新する
destroy  ...データを削除する


▷--２章


＜投稿までの処理の流れ＞
1.フォーム画面を表示する
2.フォームにデータを入力し、送信する
3.送信内容をデータベースへ保存する
4.保存した後に別のページに移動する(リダイレクト)




＜HTTPリクエストについて＞
ブラウザは表示したい（取得したい）ページを表示するために、欲しいページやデータを持っているサーバーに対して
お願いするような形でリクエストをする必要があります。
これをHTTPリクエストという。

「アプリケーションのページやデータは皆さんのブラウザが持っているわけではない」

ーHTTPリクエストの種類ー
GET	　　...データの取得(ページ自体もデータ)
POST	...新しいデータの作成
PUT	　　...既存のデータの更新
PATCH	...既存のデータの一部更新
DELETE	...既存のデータを削除




＜投稿機能に必要なHTTPリクエストは次の2つ＞
GET
POST

1.投稿フォームの作成
a) ルーティングを確認し追加する
b) コントローラーの記述を確認し追加する
c) form_withヘルパーでフォームを作成する




＜form_withヘルパーとは＞
Railsには、Viewなどから呼び出す共通処理をまとめた「ヘルパーメソッド」が用意
セキュリティ対策などが組み込まれた安全なHTMLのformタグを作成でき、
またRailsの機能を最大限生かすことが可能

form_withはViewで使用することができ、基本形は次のようになっていてdoからendまでが範囲
ーーーーーーーーーーーー
<%= form_with do |f| %>
<% end %>
ーーーーーーーーーーーー
[解説]
<%で始まるタグは、Rubyで使われるタグです。

<% %>では、タグ内の結果がHTMLに変換されずに処理されます。
<%= %>では、タグ内の結果がHTMLに変換されます。


！今回作成するSampleAppでは、
フォームからデータを送信した後に
データベースへ保存する必要があるため
Listモデルと連携を行う必要があり、
その情報を含めるとform_withは次のようになります。！

[基本形からListモデルと連携したform_with]
ーーーーーーーーーーーーーーーーーーーー
<%= form_with model: List.new do |f| %>
<% end %>
ーーーーーーーーーーーーーーーーーーーー


＜インスタンス変数とは＞
コントローラーアクションとViewファイルでデータの受け渡しができる変数のことで
@helloのように変数名の先頭に「@(アットマーク)」を付けることでインスタンス変数となります。

例）コントローラーのnewアクションにインスタンス変数を定義すると
　　対応するViewであるnew.html.erbでその変数を呼び出すことができるというものになります。

[コントローラ/アクション]
　ーーーーーーーーー
　def new
　 @hello = "Hello"
　end
　ーーーーーーーーー

[Viewファイル]
　ーーーーーーー
　<%= @hello %>
　ーーーーーーー
　[解説]
　ブラウザに「Hello」と出力される
　
　
＜ローカル変数＞
インスタンス変数の逆で
コントローラーとViewファイルでデータの受け渡しが
できない変数のこと

[コントローラ/アクション]
　ーーーーーーーーー
　def new
　 hello = "Hello"
　end
　ーーーーーーーーー
　[解説]
　変数名の先頭に何も付けない場合
　「＠」がなくなっている

[Viewファイル]
表示が出来ずにエラーが発生



！違いのまとめ！
ーインスタンス変数ー
# 変数の名前の先頭に@マークをつける
# コントローラーとViewでデータの受け渡しができる

ーローカル変数ー
# 変数の名前の先頭には何もつけない
# コントローラーとViewでデータの受け渡しができない


＜保存機能を追加する＞
１コントローラに記述を追加する
# 投稿フォームのあるページを表示するnewアクション
# 投稿を保存するためのcreateアクション
# createアクションを作成する

＜createアクション内の処理の流れ＞
1. フォームに記述した文字やデータを受け取る
2. 受け取ったデータを元にインスタンスを作成する
3. インスタンスにsaveメソッドを使いデータベースに保存する
4. 画面遷移（リダイレクト）を行う

＜ストロングパラメータ＞
●params...formから送られてくるデータはparamsの中に入っています。
●require...送られてきたデータの中からモデル名(ここでは:list)を指定し、データを絞り込みます。
●permit...requireで絞り込んだデータの中から、保存を許可するカラムを指定します。

  古いバージョンのRailsでは、実装によっては
  フォームから送られてきたデータを全て保存することができました。
  そのため、悪意のあるユーザーが改竄したデータを送信した場合も、
  そのデータは保存されてしまいます。
  これが、マスアサインメント脆弱性です。
  Railsでは、この脆弱性を防ぐ「ストロングパラメータ」の仕組みが用意されています。
  
  
＜メソッドの呼び出しに制限をかける＞
Controllerに「def list_params...」を直接書いてしまうと、アクション(URLと1対1で対応するもの)として認識されてしまいます。
例えばnewアクションは/lists/newというURLと紐づいています。
list_paramsは本来createアクションの内部で扱いたいものですが、list_paramsがアクションとして認識されてしまうと
「何らかのURLでlist_paramsだけを呼び出すことができる」という脆弱性が生じてしまいます。
そこで、「private」の行より下に記述することで、メソッドの呼び出しに制限をかけることができます。
privateより後に定義されたメソッドは、アクションとして認識されなくなり、URLと対応できなくなります。

●privateメソッド...「モデル名_params」


▷--３章


＜一覧画面表示までの流れ＞
1.コントローラで、データベースからlistsテーブルに保存されているデータを取得する
2.取得したデータをインスタンス変数に格納する
3.ビューファイルでインスタンス変数が書かれている部分を、データに置き換える
4.データから投稿を一つずつ取り出し、表示する


▷--４章


＜詳細画面表示までの流れ＞
1.コントローラで、データベースからlistsテーブルに保存されているデータを一つだけ取得する
2.取得したデータをインスタンス変数に格納する
3.ビューファイルでインスタンス変数とメソッドが書かれている部分を、データで置き換える

ー準備ー
●詳細画面を表示させるためのルーティングを設定する
●一覧画面から詳細画面に遷移できるようにリンクを作成する


get 'lists/:id' => 'lists#show'
# URLの部分は、lists/:idのように、idの前に :（コロン）を付けて指定

詳細画面...どの投稿データを表示するかを判別するために、投稿データのidもURLに含めます。
# 詳細画面で呼び出される投稿データは、「:id」で判別


＜show.html.erbを作成する＞
本当にURLによって取得するレコードが変わっているのかどうか
を確認するため、ビューに記述をしていきます。

サーバーを起動し確認
https://...amazonaws.com/lists/1へアクセス

＜indexにshowへのリンクを作る＞
一覧画面から詳細画面へ遷移するリンクを設定

link_toメソッド...HTMLの要素を出力するメソッド

[記述の仕方]
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
<%= link_to 表示させるテキスト , リンク先URL [,オプション] %>
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
[解説]
リンク先URLは、/lists/:idの「:idに該当する部分」を指定します。
オプションは、今回は設定しません。


＜ルーティング(名前付きルート)＞
文字通りルーティング自体に名前をつけておくこと
その名前をredirect_toやlink_toでも使用することができます。

＜まとめ＞
投稿の詳細画面では特定のデータ1つをデータベースから取得する。
特定のデータ1つは「モデル名.find(params[:id])」で取得する。
取得したデータ1つをインスタンス変数に格納する。
 詳細画面の表示はデータ1つを格納したインスタンス変数をviewファイルで利用する。
リンクにはlink_toメソッドを利用する。


▷--５章


＜編集機能の流れ＞
1.コントローラで、データベースからlistsテーブルに保存されているデータを一つだけ取得する
2.取得したデータをインスタンス変数に格納する
3.編集画面のビューファイルで、"form_with"にインスタンス変数を渡すことで、フォームの入力内容を取得したデータで置き換える
4.フォームの内容を書き換える
5.保存ボタンをクリックすると、書き換えた内容がデータベースに保存される
6.保存した後に別のページに移動する(リダイレクト)

ー準備ー
●編集画面を表示させるためのルーティングを設定する
●更新処理を行うためのルーティングを設定する

＜更新機能を追加＞
ーコントローラー
更新機能のためのアクション、updateアクションを作成
# updateアクション
# データの更新後に更新結果を詳細画面に表示するために
  showアクションにリダイレクト
# 新たなビューは作成しません。

# showアクションにリダイレクトするために、
  引数には必ずidが必要になります。
# idを付けることで、どのデータを詳細画面で表示させるのかを決定
# idの設定を忘れないよう注意

＜まとめ＞
投稿データの編集は編集対象のデータを取得し、編集画面を表示する。
編集対象のデータは「モデル名.find(params[:id])」で取得する。
取得したデータ1つをインスタンス変数に格納する。
編集画面の表示はデータ1つを格納したインスタンス変数をviewファイルで利用する。
編集したデータの更新はupdateメソッドで行う。


▷--６章


＜画像投稿機能を作ろう＞
画像を投稿できるようにするには、ActiveStorageというものを使います。

＜ActiveStorageとは＞
Railsで画像の投稿や表示を行うためのもの
# 画像は通常のカラムとして保存できない
# 特別な保存方法が必要 = ActiveStorage

#どのモデルに対して画像を使うのかを宣言する必要

＜まとめ＞
ActiveStorageをインストールする
モデルにhas_one_attachedメソッドを追加する。
画像アップロード用のフィールドをviewファイルに記述する。
画像表示するためにimage_tagをviewファイルに記述する


▷--7章


＜削除機能作成の流れ＞
1.削除リンクをクリック
2.listsコントローラのdestroyアクションが呼び出される
3.当該のレコードを削除
4.一覧ページにリダイレクトする

ー実装手順ー
A.ルーティングを作成する
B.destroyアクションを作成し、レコードの削除、リダイレクトの記述をする
C.link_toでdestroyアクションを呼び出せるようにする

A.destroyアクション用に、ルーティングを追加

●HTTPメソッド...DELETE
●URL...lists/:id
●名前付きパス...destroy_listと設定

＜link_toのmethodオプションについて＞
今まで、link_toを作成して画面の遷移を行なってきていましたが
それらは全てHTTPメソッドがGETになっています。
そのため、このままでは以下のことができません。

●update <= HTTPメソッドがPATCHのため
●destroy <= HTTPメソッドがDELETEのため
●create <= HTTPメソッドがPOSTのため

# これらのアクションを実行するためにはURLだけではなく
# HTTPメソッドも指定しなければなりません。

link_toのmethodオプション...URLに対してHTTPメソッドを設定するためのオプション

ーーーーーーーーーーーーーーーーーーーーーーーーーーーー
<%= link_to '表示するテキスト', URL, method: :patch %>
ーーーーーーーーーーーーーーーーーーーーーーーーーーーー
※methodオプション以外は簡略化してあります。
ルーティングの中から
「HTTPメソッドがPATCHでURLが同じ」
という条件で実行するべきアクションを探して実行してくれます。

＜CRUD処理とは＞
ウェブアプリケーションの基本であるCRUD（クラッド）機能を実装
「データベースの基本的な処理のこと」
「Railsでは保存、取得、更新、削除のこと」

● create（作成）
  # 例：list.save
● read（読み取り）
  # 例：List.all, List.find(params[:id])
● update（更新）
  # 例：list.update(list_params)
● destroy（削除）
  # 例：list.destroy
  
＜ルーティングの記述を短縮できる書き方＞
resourcesメソッド...ルーティングを一括して自動生成してくれる機能


＜まとめ＞
削除機能は削除用のルーティングの追加とdestroyアクションを作成する。
削除用ボタンにはlink_toを使用して、「method: :delete」を指定する。
 「method: :delete」を指定することで、削除ボタンを押すと削除用のルーティングを経由してdestroyアクションを呼び出す。
データの削除にはdestroyメソッドを使用する。


▷--8章


＜バリデーションとは＞
画像、タイトル、本文が「必須」入力になるように設定
このような入力チェックを、「バリデーション」と呼びます。


＜バリデーションを設定する＞
モデルのファイルに設定内容を記述します。
今回、投稿に対して「必須入力」の設定が必要なので、Listモデルに記述を追加します。

＜まとめ＞
バリデーションの設定はモデルに行う。
バリデーションによるエラーメッセージはview側でerrorsを使用して表示する。


▷--9章


＜ビューファイルを作成しないアクション＞
●createアクション
●destroyアクション
●updateアクション

ーこの場合のビュー表示ー
1.redirect_toを用いてHTTPリクエストを行う
2.renderを用いて別のアクションに対応するビューを表示

※ Railsでアプリケーションを制作する際に必ずと言って良いほど利用する
  #処理の流れや使い方の違いをしっかりと理解する必要


＜renderとredirect_toの違い＞

[redirect_to]　

#は現在地

1. redirect_toがルーティングにURLを送る 
   # Controller > createアクション 
   # redirect_to(indexへのURL)
2. ルーティングと送られてきたURLとHTTPメソッドを照らし合わせて、どのコントローラのどのアクションを実行するかを決める
   # Routing
3. アクションを実行する
   # Controller > indexアクション
4. ビューを表示する
   # View
   # index.html.erb
   
「ブラウザにURLを打ち込む代わりに
redirect_toで画面が遷移できる」と考える

[render]
1. renderで定義したビューファイルを表示する。
   # Controller > createアクション
   # render :index
4. ビューを表示する
   # View
   # index.html.erb

「直接ビューファイルを表示させています。」
画面の遷移はなく、表示されているHTMLが入れ替わる


ー２つの違いー
新たにアクションを実行するかしないかという点

● render
アクションを新たに実行しない
● redirect_to
アクションを新たに実行する

例）newアクションを実行すると、
　　newアクションの中に定義されている
　　インスタンス変数@listが用意されます。
　　
基本的には、エラーメッセージを扱う際にはrender、
それ以外はredirect_toを使うと覚えておきましょう。


＜まとめ＞
redirect_toはアクションを実行する
renderはアクションを実行しない
ビューは自身が呼び出されたアクション内からインスタンス変数を参照する
renderを使う際、ビューの表示に必要なインスタンス変数を用意しなくてはならない
renderの性質を利用してエラーメッセージを表示することができる
